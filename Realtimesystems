


Real-Time Operating Systems Save Lives

Introduction

In an ever-evolving world of computers researchers have looked into various ways to increase the effectiveness of operating systems in the real world and real-time operating systems (RTOS) are one of the solutions. The reason real-time operating systems are so important and I chose this topic is because the idea of these real-time systems literally saves lives. Usually normal operating  systems use pre-compiled algorithms using data that usually stays the same and these systems will always never have to meet a certain deadline, but with RTOS an important deadline always exists and play a big role on the device. A good example of the idea behind these systems is with a car airbag. Let's say you are driving 70MPH down the highway and you get in a car accident. The airbag will deploy right on time saving your life and anyone else's life in the car as well. The time taken between when the car hit something and the airbag being released is the response time. Real-time operating systems have well-defined, fixed time constraints so they will usually always work in a situation like that without fail. The problem with regular operating systems is that they struggle with in taking real-time data and they also struggle with taking in I/O real-time data. It is definitely possible for them to work with real-time data and I/O but they run into many problems that cannot be there when dealing with important tasks like hospital and military machines. There are three types of RTOS of which are, hard RTOS, soft RTOS, and firm RTOS. The different types of RTOS are important in different types of situations. Even though RTOS seem like they are used in many devices we do not have access to such as medical and military devices, familiar OS such as Linux, Windows CE, and LynxOS use RTOS. Even though RTOS are used on some very sophisticated equipment that can be used to save lives, you would think that a normal person could not use these systems on their normal computer, but that is wrong. RTOS can be used as an extension on normal operating systems and can be used with a personal computer. The main reason behind this paper is to educate the reader on RTOS, find problems with RTOS in real-life situations so that lives can be saved, and discuss everyday use with RTOS.

RTOS Application

As mentioned above RTOS are used in some of the most important areas of the world such as, military machines, medical devices, devices for handicapped people, and business use. There are many kinds of RTOS but there are three main types which are hard, soft and firm RTOS. Hard RTOS strictly follow the deadline associated with the tasks. Missing a deadline or an important moment can have devastating effects and even cost someone their life. The airbag examples above is a good example of a hard RTOS. Then there are firm RTOS which are also required to follow a deadline but missing this deadline may not cause a devastating affect like someone losing their life. However, it can still cause a terrible moment that affects a huge problem with a product or giving out false data to big organizations leading to huge money loss. The lastly there are soft RTOS which unlike the other two missing a deadline is completely acceptable. For example, online databases and storage centers. Some features of an RTOS that differs from regular operating systems are that the context latency should be short. This means that the time taken while saving the context of the current task and then switching over to another task should be short. Also with RTOS the time taken between executing the last instruction of an interrupted task and executing the first instruction of interrupt handler should be predictable and short. This is also called interrupt latency. Similarly, the time taken between executing the last instruction of the interrupt handler and executing the next task should also be short and predictable. This is otherwise known as interrupting  dispatch latency. Since RTOS always rely on precise timing and data, reliable and time bound inter process mechanisms should be in place for processes to communicate with each other in a timely manner. Lastly an RTOS should always have support for multitasking and task preemption. Task preemption means to switch from a currently executing task to a high priority task ready and waiting to be executed. Even though RTOS can be used in certain versions of windows and Linux, this doesn't mean you can use these systems in normal operating systems we use on our everyday computers. The main reason we cannot use RTOS on our current laptops and computers are because RTOS generally require a very simple, minimal kernel where time spend in different tasks is very predictable. The beat, everything can be considered when scheduling. Even then, there's sometimes still a degree of slushiness because of the granularity, hardware limitations and resource contention.

RTOS Errors and Challenges

Even though some RTOS are used in life or death situations, there are still sometimes errors, glitches, or bugs that can occur and with deadly consequences like saving a person's life, there cannot be any errors allowed. In order to try and prevent errors with RTOS you must understand the current errors and problems with these systems. One of the biggest problems with RTOS is that they are extremely difficult to debug and it takes a lot of time to do so. RTOS can introduce problems that most operating systems do not encounter as much such as priority invasion, dead-lock, and task jitter. However, some new techniques can be used to help speed up the process of debugging in RTOS. One of these new techniques used to debug a systems is called tracing. These tracing tools can record when tasks start and end execution and when events occur such as data being placed in a message queue or a mutex being locked. Tracing tools can even be used to verify that the application is executing as expected. This is very useful in testing when an airbag needs to be deployed because it can track when exactly it was deployed and compare it to when the car actually hit. Another big problem when switching to RTOS is managing the memory. Because of the unique application with RTOS, managing and allocating memory is a very important task to accomplish. There are several layers to memory management when using an RTOS. Developers need to properly manage their RTOS objects and how to allocate memory in their system. Using the heap and byte pools can result in non-deterministic behavior along with memory fragmentation. Using the RTOS default stack size can result in using too much RAM, or stack overflow. Some of these issues can be solved by performing a worst case stack analysis and by using block memory pools, but these issues can even then be very difficult. Developers also need to configure their RTOS to minimize code size if they are using a recourse constrained device. Usually RTOS optimization will require adjusting the RTOS configuration file to disable features that use a lot of code space or RAM. This is very important to realize because not every device that uses RTOS uses the same memory and CPU processing. Similar to normal operating systems setting task priorities is very important, especially when dealing with hard RTOS. If developers working with RTOS simply randomly assign priorities based on how important they feel the task is, most always the RTOS will fail and cause catastrophic errors. Developers should start by using rate monotonic scheduling to get an understanding for whether their periodical task can be scheduled successfully. RMS assumes that tasks are periodic and do not interact with each other so it only serves as a starting point but can help developers get a head start. As mentioned above, developers can use trace tools to observe how the systems acts and make adjustments accordingly. So, when switching to an RTOS or when using a device that uses a RTOS you must be able to solve these interesting and unique problems and even with a general understanding on regular operating systems, switching or working with an RTOS can be a challenge. 

RTOS Commercial Products

	Even though RTOS are usually used for complicated machines that require a deadline to be met, they can be used in everyday commercial products that normal people use. Many products that use RTOS are usually an extension so it can be used in certain situations. Some great examples of RTOS as an extension are Unix to RT-Unix and Windows to Windows CE. Even though RTOS are used for these products they are generally slower and less predictable than the normal kernels, but they have greater functionality and better software development environments. For Unix there are many other extensions and variations and because of this an IEEE standardization effort, called POSIX, which has introduced a common set of user-level interfaces. The common set includes eleven important real-time related functions: timers, priority scheduling, shared memory, real-time files, semaphores, interprocess communication, asynchronous event notification, asynchronous I/O, memory locking, synchronous I/O, and threads. However, these extensions can only be used in certain situations and only when certain parameters are met. If you tried to convert non-real-time systems to real-time systems, various problems will occur. For example, with Unix non real time operating systems it uses a round robin scheduling algorithm, and there will be major interface problems with process scheduling because of this policy. Another problem when trying to convert these two different systems for commercial use is that the timer facilities are too coarse, memory management contains no method for locking pages into memory, and interprocess communication facilities do not support fast and predictable communication often resulting in different forms of priority inversion. Methods have been implemented to help fix these problems when trying to convert from the two different operating systems, and if possible, developers need to be careful not to use certain non-real-time features that might negatively impact the real-time tasks. If developers understand this concept when trying to convert and use real-time systems with non-real-time systems, than the implementation will be much easier and more successful. Now when actually adding real-time capabilities to current systems, methods have been put into place for developers. These methods are compliant kernels, dual kernels, core kernel modifications, and a resource kernel approach. Compliant kernels is an approach when as existing real-time operating system is modified so that Linux binaries can be run without any modification. Using dual kernels is an approach that basically runs the native operating system as its lowest priority task, and puts the real-time processes and tasks in a much higher priority queue. The core kernel modification approach is when changes are made to the core of a non-real-time kernel in order to make it predictable and deterministic enough so as to behave as a real-time operating system. Lastly, the resource kernel approach is when the kernel is extended to provide support for resource reservations in addition to the traditional fixed-priority preemptive scheduling approach. Now as you can see there are many ways to be able to use real-time operating systems whether it be as an extension of a regular operating system or used within a normal operating system together at the same time. 

Conclusion

	Real-time operating systems are one of the most important systems put into place in our world. They are literally used to save lives whether it be for deciding the split-second moment a car airbag needs to come on, or shooting down a military missile that was directed toward the citizens of the United States of America. Since RTOS are used in such important devices and situations, the way these systems work is very complex and is explained to a high degree. Developers need to not only understand the way normal operating systems work, but also understand how RTOS are different and work much differently. Even though RTOS are used in important companies such as military and medical companies, an everyday person can also use these systems and even parallel to non-real-time operating systems. The use of RTOS is commercial devices is being implemented much more now that developers are starting to understand the importance and power behind these systems. In our ever-evolving world of business, medical, and military machines, RTOS are a prime example of how these huge important companies can achieve such great results; and with the rapid development of technology within our communities, RTOS are being used alongside normal everyday operating systems today.
